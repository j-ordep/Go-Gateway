<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/cmd/app/main.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cmd/app/main.go" />
              <option name="originalContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;os&quot;&#10;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/repository&quot;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/service&quot;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/web/server&quot;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;&#10;&#9;_ &quot;github.com/lib/pq&quot;&#10;)&#10;&#10;func getEnv(key, defaultValue string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return defaultValue&#10;}&#10;&#10;func main() {&#10;&#9;if err := godotenv.Load(); err != nil {&#10;&#9;&#9;log.Fatal(&quot;Error loading .env file&quot;)&#10;&#9;}&#10;&#10;&#9;connStr := fmt.Sprintf(&#10;&#9;&#9;&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;getEnv(&quot;DB_HOST&quot;, &quot;db&quot;),&#10;&#9;&#9;getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#10;&#9;&#9;getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#10;&#9;&#9;getEnv(&quot;DB_PASSWORD&quot;, &quot;postgres&quot;),&#10;&#9;&#9;getEnv(&quot;DB_NAME&quot;, &quot;gateway&quot;),&#10;&#9;&#9;getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#10;&#9;)&#10;&#10;&#9;db, err := sql.Open(&quot;postgres&quot;, connStr)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatal(&quot;Error connecting to db: &quot;, err)&#10;&#9;}&#10;&#9;defer db.Close()&#10;&#10;&#9;// Configura e inicializa o Kafka&#10;&#9;baseKafkaConfig := service.NewKafkaConfig()&#10;&#10;&#9;// Configura e inicializa o produtor Kafka&#10;&#9;producerTopic := getEnv(&quot;KAFKA_PRODUCER_TOPIC&quot;, &quot;pending_transactions&quot;)&#10;&#9;producerConfig := baseKafkaConfig.WithTopic(producerTopic)&#10;&#10;&#9;kafkaProducer := service.NewKafkaProducer(producerConfig)&#10;&#9;defer kafkaProducer.Close()&#10;&#10;&#9;accountRepository := repository.NewAccountRepository(db)&#10;&#9;accountService := service.NewAccountService(accountRepository)&#10;&#10;&#9;invoiceRepository := repository.NewInvoiceRepository(db)&#10;&#9;invoiceService := service.NewInvoiceService(invoiceRepository, *accountService, kafkaProducer)&#10;&#10;&#9;// Ajuste: alinhar com docker-compose.yml e .env&#10;&#9;// docker-compose cria o tópico 'transactions_result'&#10;&#9;// README/.env usam KAFKA_TRANSACTIONS_RESULT_TOPIC&#10;&#9;consumerTopic := getEnv(&quot;KAFKA_TRANSACTIONS_RESULT_TOPIC&quot;, &quot;transactions_result&quot;)&#10;&#9;consumerConfig := baseKafkaConfig.WithTopic(consumerTopic)&#10;&#9;groupID := getEnv(&quot;KAFKA_CONSUMER_GROUP_ID&quot;, &quot;gateway-group&quot;)&#10;&#10;&#9;kafkaConsumer := service.NewKafkaConsumer(consumerConfig, groupID, invoiceService)&#10;&#9;defer kafkaConsumer.Close()&#10;&#10;&#9;go func() {&#10;&#9;&#9;if err := kafkaConsumer.Consume(context.Background()); err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;Error consuming kafka messages: %v&quot;, err)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;port := getEnv(&quot;HTTP_PORT&quot;, &quot;8081&quot;)&#10;&#10;&#9;srv := server.NewServer(accountService, invoiceService, port)&#10;&#9;srv.ConfigureRoutes() // handler esta aqui encapsulado&#10;&#10;&#9;if err := srv.Start(); err != nil {&#10;&#9;&#9;log.Fatal(&quot;Error starting server: &quot;, err)&#10;&#9;}&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package main&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;os&quot;&#10;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/repository&quot;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/service&quot;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/web/server&quot;&#10;&#9;&quot;github.com/joho/godotenv&quot;&#10;&#10;&#9;_ &quot;github.com/lib/pq&quot;&#10;)&#10;&#10;func getEnv(key, defaultValue string) string {&#10;&#9;if value := os.Getenv(key); value != &quot;&quot; {&#10;&#9;&#9;return value&#10;&#9;}&#10;&#9;return defaultValue&#10;}&#10;&#10;func main() {&#10;&#9;if err := godotenv.Load(); err != nil {&#10;&#9;&#9;log.Fatal(&quot;Error loading .env file&quot;)&#10;&#9;}&#10;&#10;&#9;connStr := fmt.Sprintf(&#10;&#9;&#9;&quot;host=%s port=%s user=%s password=%s dbname=%s sslmode=%s&quot;,&#10;&#9;&#9;getEnv(&quot;DB_HOST&quot;, &quot;db&quot;),&#10;&#9;&#9;getEnv(&quot;DB_PORT&quot;, &quot;5432&quot;),&#10;&#9;&#9;getEnv(&quot;DB_USER&quot;, &quot;postgres&quot;),&#10;&#9;&#9;getEnv(&quot;DB_PASSWORD&quot;, &quot;postgres&quot;),&#10;&#9;&#9;getEnv(&quot;DB_NAME&quot;, &quot;gateway&quot;),&#10;&#9;&#9;getEnv(&quot;DB_SSL_MODE&quot;, &quot;disable&quot;),&#10;&#9;)&#10;&#10;&#9;db, err := sql.Open(&quot;postgres&quot;, connStr)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Fatal(&quot;Error connecting to db: &quot;, err)&#10;&#9;}&#10;&#9;defer db.Close()&#10;&#10;&#9;// Configura e inicializa o Kafka&#10;&#9;baseKafkaConfig := service.NewKafkaConfig()&#10;&#10;&#9;// Configura e inicializa o produtor Kafka&#10;&#9;producerTopic := getEnv(&quot;KAFKA_PRODUCER_TOPIC&quot;, &quot;pending_transactions&quot;)&#10;&#9;producerConfig := baseKafkaConfig.WithTopic(producerTopic)&#10;&#10;&#9;kafkaProducer := service.NewKafkaProducer(producerConfig)&#10;&#9;defer kafkaProducer.Close()&#10;&#10;&#9;accountRepository := repository.NewAccountRepository(db)&#10;&#9;accountService := service.NewAccountService(accountRepository)&#10;&#10;&#9;invoiceRepository := repository.NewInvoiceRepository(db)&#10;&#9;invoiceService := service.NewInvoiceService(invoiceRepository, *accountService, kafkaProducer)&#10;&#10;&#9;// Ajuste: alinhar com docker-compose.yml e .env&#10;&#9;// docker-compose cria o tópico 'transactions_result'&#10;&#9;// README/.env usam KAFKA_TRANSACTIONS_RESULT_TOPIC&#10;&#9;consumerTopic := getEnv(&quot;KAFKA_TRANSACTIONS_RESULT_TOPIC&quot;, &quot;transactions_result&quot;)&#10;&#9;consumerConfig := baseKafkaConfig.WithTopic(consumerTopic)&#10;&#9;groupID := getEnv(&quot;KAFKA_CONSUMER_GROUP_ID&quot;, &quot;gateway-group&quot;)&#10;&#10;&#9;kafkaConsumer := service.NewKafkaConsumer(consumerConfig, groupID, invoiceService)&#10;&#9;defer kafkaConsumer.Close()&#10;&#10;&#9;go func() {&#10;&#9;&#9;if err := kafkaConsumer.Consume(context.Background()); err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;Error consuming kafka messages: %v&quot;, err)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;port := getEnv(&quot;HTTP_PORT&quot;, &quot;8081&quot;)&#10;&#10;&#9;srv := server.NewServer(accountService, invoiceService, port)&#10;&#9;srv.ConfigureRoutes() // handler esta aqui encapsulado&#10;&#10;&#9;if err := srv.Start(); err != nil {&#10;&#9;&#9;log.Fatal(&quot;Error starting server: &quot;, err)&#10;&#9;}&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/internal/service/invoice_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/internal/service/invoice_service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/domain&quot;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/domain/events&quot;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/dto&quot;&#10;)&#10;&#10;type InvoiceService struct {&#10;&#9;invoiceRepository domain.InvoiceRepository&#10;&#9;accountService    AccountService&#10;&#9;kafkaProducer     KafkaProducerInterface&#10;}&#10;&#10;func NewInvoiceService(invoiceRepository domain.InvoiceRepository, accountService AccountService, kafkaProducer KafkaProducerInterface) *InvoiceService {&#10;&#9;return &amp;InvoiceService{&#10;&#9;&#9;invoiceRepository: invoiceRepository,&#10;&#9;&#9;accountService:    accountService,&#10;&#9;&#9;kafkaProducer:     kafkaProducer,&#10;&#9;}&#10;}&#10;&#10;func (s *InvoiceService) Create(input dto.CreateInvoiceInput) (*dto.InvoiceOutput, error) {&#10;&#9;accountOutput, err := s.accountService.FindByAPIKey(input.APIKey)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;invoice, err := dto.ToInvoice(input, accountOutput.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if err = invoice.Process(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if invoice.Status == domain.StatusPending {&#10;&#9;&#9;// Criar e publicar evento de transação pendente&#10;&#9;&#9;pendingTransaction := events.NewPendingTransaction(invoice.AccountID, invoice.ID, invoice.Amount)&#10;&#10;&#9;&#9;if err := s.kafkaProducer.SendingPendingTransaction(context.Background(), *pendingTransaction); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if invoice.Status == domain.StatusApproved {&#10;&#9;&#9;_, err := s.accountService.UpdateBalance(input.APIKey, invoice.Amount)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err = s.invoiceRepository.Save(invoice); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return dto.FromInvoice(invoice), nil&#10;&#10;}&#10;&#10;func (s *InvoiceService) GetById(id, apiKey string) (*dto.InvoiceOutput, error) {&#10;&#9;invoice, err := s.invoiceRepository.FindByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;accountOutput, err := s.accountService.FindByAPIKey(apiKey)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if invoice.AccountID != accountOutput.ID {&#10;&#9;&#9;return nil, domain.ErrUnauthorizedAccess&#10;&#9;}&#10;&#10;&#9;return dto.FromInvoice(invoice), nil&#10;}&#10;&#10;func (s *InvoiceService) ListByAccountApiKey(apiKey string) ([]*dto.InvoiceOutput, error) {&#10;&#9;accountOutput, err := s.accountService.FindByAPIKey(apiKey)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return s.ListByAccountId(accountOutput.ID)&#10;}&#10;&#10;// func auxiliar para ListByAccountApiKey&#10;func (s *InvoiceService) ListByAccountId(accountId string) ([]*dto.InvoiceOutput, error) {&#10;&#9;invoices, err := s.invoiceRepository.FindByAccountID(accountId)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;invoiceOutput := make([]*dto.InvoiceOutput, len(invoices))&#10;&#9;for i, invoice := range invoices {&#10;&#9;&#9;invoiceOutput[i] = dto.FromInvoice(invoice)&#10;&#9;}&#10;&#10;&#9;return invoiceOutput, nil&#10;}&#10;&#10;// ProcessTransactionResult processa o resultado de uma transação após análise de fraude&#10;func (s *InvoiceService) ProcessTransactionResult(invoiceID string, status domain.Status) error {&#10;&#9;invoice, err := s.invoiceRepository.FindByID(invoiceID)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if err := invoice.UpdateStatus(status); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if err := s.invoiceRepository.UpdateStatus(invoice); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if status == domain.StatusApproved {&#10;&#9;&#9;account, err := s.accountService.FindByID(invoice.AccountID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if _, err := s.accountService.UpdateBalance(account.APIKey, invoice.Amount); err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/domain&quot;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/domain/events&quot;&#10;&#9;&quot;github.com/j-ordep/gateway/go-gateway/internal/dto&quot;&#10;)&#10;&#10;type InvoiceService struct {&#10;&#9;invoiceRepository domain.InvoiceRepository&#10;&#9;accountService    AccountService&#10;&#9;kafkaProducer     KafkaProducerInterface&#10;}&#10;&#10;func NewInvoiceService(invoiceRepository domain.InvoiceRepository, accountService AccountService, kafkaProducer KafkaProducerInterface) *InvoiceService {&#10;&#9;return &amp;InvoiceService{&#10;&#9;&#9;invoiceRepository: invoiceRepository,&#10;&#9;&#9;accountService:    accountService,&#10;&#9;&#9;kafkaProducer:     kafkaProducer,&#10;&#9;}&#10;}&#10;&#10;func (s *InvoiceService) Create(input dto.CreateInvoiceInput) (*dto.InvoiceOutput, error) {&#10;&#9;accountOutput, err := s.accountService.FindByAPIKey(input.APIKey)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;invoice, err := dto.ToInvoice(input, accountOutput.ID)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if err = invoice.Process(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if invoice.Status == domain.StatusPending {&#10;&#9;&#9;// Criar e publicar evento de transação pendente&#10;&#9;&#9;pendingTransaction := events.NewPendingTransaction(invoice.AccountID, invoice.ID, invoice.Amount)&#10;&#10;&#9;&#9;if err := s.kafkaProducer.SendingPendingTransaction(context.Background(), *pendingTransaction); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if invoice.Status == domain.StatusApproved {&#10;&#9;&#9;_, err := s.accountService.UpdateBalance(input.APIKey, invoice.Amount)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err = s.invoiceRepository.Save(invoice); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return dto.FromInvoice(invoice), nil&#10;&#10;}&#10;&#10;func (s *InvoiceService) GetById(id, apiKey string) (*dto.InvoiceOutput, error) {&#10;&#9;invoice, err := s.invoiceRepository.FindByID(id)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;accountOutput, err := s.accountService.FindByAPIKey(apiKey)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;if invoice.AccountID != accountOutput.ID {&#10;&#9;&#9;return nil, domain.ErrUnauthorizedAccess&#10;&#9;}&#10;&#10;&#9;return dto.FromInvoice(invoice), nil&#10;}&#10;&#10;func (s *InvoiceService) ListByAccountApiKey(apiKey string) ([]*dto.InvoiceOutput, error) {&#10;&#9;accountOutput, err := s.accountService.FindByAPIKey(apiKey)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return s.ListByAccountId(accountOutput.ID)&#10;}&#10;&#10;// func auxiliar para ListByAccountApiKey&#10;func (s *InvoiceService) ListByAccountId(accountId string) ([]*dto.InvoiceOutput, error) {&#10;&#9;invoices, err := s.invoiceRepository.FindByAccountID(accountId)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;invoiceOutput := make([]*dto.InvoiceOutput, len(invoices))&#10;&#9;for i, invoice := range invoices {&#10;&#9;&#9;invoiceOutput[i] = dto.FromInvoice(invoice)&#10;&#9;}&#10;&#10;&#9;return invoiceOutput, nil&#10;}&#10;&#10;// ProcessTransactionResult processa o resultado de uma transação após análise de fraude&#10;func (s *InvoiceService) ProcessTransactionResult(invoiceID string, status domain.Status) error {&#10;&#9;invoice, err := s.invoiceRepository.FindByID(invoiceID)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if err := invoice.UpdateStatus(status); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if err := s.invoiceRepository.UpdateStatus(invoice); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if status == domain.StatusApproved {&#10;&#9;&#9;account, err := s.accountService.FindByID(invoice.AccountID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if _, err := s.accountService.UpdateBalance(account.APIKey, invoice.Amount); err != nil {&#10;&#9;&#9;&#9;return err&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>